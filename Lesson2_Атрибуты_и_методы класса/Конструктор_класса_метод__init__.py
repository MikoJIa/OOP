# Большинство классов имеют специальный метод, который автоматически при создании объекта создаёт ему атрибуты. То есть
# вызывать данный метод не нужно, т.к. он сам запускается при вызове класса.(Вызов класса происходит, когда создаётся объект)
# Такой метод называется конструктором класса, в языке Python носит имя __init__
# Первым пораметром, как и у любого другого метода, у __init__ является self, на место которого подставляется объект в
# момень его создания. Второй и последующие (если есть) параметры заменяются аргументами, переданными в конструктор при вызове класса.
# Пример:
class Car:
    def __init__(self, model, year):
        self.model = model
        self.year = year
car = Car('skoda', 2008)

# Как мы выяснили ранее, в объектно-ориентированном программировании, методы используются для реализации функционалов объекта.
# До этих пор, мы использовали объекты класса для вызова методов.
# Однако, есть тип методов, который может быть вызван напрямую при помощи имени класса. Такой метод называется статичным методом.
# Статичный метод:
# Для объявления статического метода, вам нужно указать дескриптор @staticmethod перед названием метода, как показано ниже:
class Car:
    @staticmethod
    def get_class_details():
        print('Это класс Car')
Car.get_class_details()
# Стоит упомянуть, что статические методы могут иметь доступ только к атрибутам класса в Python, вы не сможете обратиться к методам через self.
# Методы класса
# Методы класса принимают класс в качестве параметра, который принято обозначать как cls. Он указывает на класс ToyClass,
#  а не на объект этого класса. При декларации методов этого вида используется декоратор classmethod.
# Методы класса привязаны к самому классу, а не его экземпляру. Они могут менять состояние класса, что отразится на всех
# объектах этого класса, но не могут менять конкретный объект.

# В каждом классе языка Python есть набор предопределенных «магических» методов. Да, это такое общепринятое название.
# Магические методы начинаются и заканчиваются двумя подчеркиваниями:
                                                    # __имя метода__
# В частности существуют два таких метода:
# __init__(self) - инициализатор объекта класса
# __del__(self) _ финализатор класса

# Первый вызывается сразу после создания экземпляра класса, а второй – перед непосредственным его удалением.
# Давайте посмотрим, как они работают и зачем нужны.
class Point():
    color = 'blue'
    circle = 2

    def set_coords(self, x, y):
        self.x = x
        self.y = y

    def get_coords(self):
        return (self.x, self.y)
    # Использовать на практике такой класс не очень удобно, так как после создания объекта:
pt = Point()
# координат x, y в нем никаких не будет. Дополнительно для этого нужно еще вызывать метод:
pt.set_coords(1, 2)
# Было бы хорошо сделать эти действия сразу в момент создания экземпляра класса.
# И поможет нам в этом магический метод __init__. Давайте сначала мы его пропишем в самом простом виде:
class Point:
    color = 'blue'
    circle = 2
# Давайте теперь сделаем так, чтобы в момент создания экземпляра класса мы могли сразу указывать значения координат точки.
    #  Для этого в инициализаторе можно прописывать дополнительные параметры:
    # Конечно, на практике, обычно, имена параметров в инициализаторе совпадают с именами создаваемых свойств и лучше
    # записать инициализатор в таком виде:
    # Также всегда следует помнить, что метод __init__ - это обычная функция, поэтому мы в качестве дополнительных
    # параметров можем указывать и фактические и формальные параметры. Например, так:
    # Тогда, при создании объектов мы можем вообще не указывать аргументы:
    def __init__(self, x=0, y=0):
        print('вызов __init__')
        self.x = x
        self.y = y
    def __del__(self):
        print('Удаление экземпляра' + str(self)) # Здесь по-прежнему self – это ссылка на экземпляр класса, который будет удален.
# Здесь первый параметр self является ссылкой на созданный экземпляр класса, через который мы создаем в этом новом
# объекте локальные свойства x, y. В результате, создавая экземпляр класса:
# И при создании объекта с таким инициализатором мы уже должны в круглых скобках передавать эти два аргумента:
# Если этого не сделать, то возникнет ошибка и объект создан не будет.
pt = Point(1, 2)
# мы увидим в консоли, что, во-первых, произошел вызов этого метода и, во-вторых,
# в объекте pt были созданы два локальных свойства x, y с нулевыми значениями:
print(pt.__dict__) # {'x': 1, 'y': 2}

# Финализатор объекта класса
# Второй аналогичный магический метод __del__ автоматически вызывается непосредственно перед уничтожением экземпляра класса.
#  Он называется финализатор.
# Давайте пропишем такой магический метод в классе Point, следующим образом: Смотреть выше!!!!!

