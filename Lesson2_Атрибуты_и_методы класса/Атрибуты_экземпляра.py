# Атрибуты экземпляра объявляются в нутри любого метода, в то время ка атрибуты класса объявляются вне любого метода.
class Car:

    # создаём атрибуты класса
    car_count = 0

    # создаём методы класса
    def start(self, name, make, model):
        print('start the engine')
        self.name = name
        self.make = make
        self.model = model
        Car.car_count += 1
    def stop(self):
        print('stop the engine')
        # В указанном выше скрипте мы создаем класс Car с одним атрибутом класса под названием car_count и три атрибута
        # экземпляра под названием name, make и model. Класс содержит один метод start(),
        # который содержит наши три атрибута экземпляров. Значения атрибутов экземпляров переданы в качестве аргументов
        # методу start(). Внутри метода start, атрибут car_count увеличен на один.

# Стоит упомянуть, что внутри метода, атрибуты экземпляра ссылаются при помощи ключевого слова self,
# в то время как атрибуты класса ссылаются при помощи названия класса.!!!!!!!

# Давайте создадим объект класса Car и вызовем метод start():
car_a = Car()
car_a.start('Corrola', 'Toyota', 2015) # Двигатель заведён
print(car_a.name) # Corrola
print(car_a.car_count) # 1
print(car_a.stop()) # stop the engine

# Тепер создадим ещё один объкт класса Car и вызовем метод start():
car_b = Car()
car_b.start('Accord', 'Honda', 2006) # Двигатель заведён
print(car_b.name) # Accord
print(car_b.car_count) # 2
print(car_b.stop()) # stop the engine
# Сейчас если вы выведите значение атрибута car_count, вы увидите 2 в выдаче. Это связано с тем, что атрибут car_count
# является атрибутом класса и таким образом он разделяется между экземплярами. Объект car_a увеличил свое значение до 1,
#  в то время как car_b увеличил свое значение еще раз, так что итоговое значение равняется 2.
# Выдача выглядит следующим образом:
# Двигатель заведён
# Accord
# 2

# Давайте, для примера объявим метод set_coords в классе Point, который будет просто выводить в консоль сообщение «вызов метода set_coords»:
class Point:
    color = 'red'
    circle = 2

    def set_coords(self):
        print('вызов метода set_coords' + str(self))

# То есть, когда метод вызывается через класс, то Python автоматически не подставляет никаких аргументов.
# А когда вызов идет через экземпляры класса, то первый аргумент – это всегда ссылка на экземпляр. Данный момент нужно знать и помнить.
# Point.set_coords()
# А вот так можно вызвать метод через экземпляр
pt = Point()
pt.set_coords() #вызов метода set_coords<__main__.Point object at 0x0000014A2BFFCAC0>
# Но мы все же можем вызвать метод set_coords и через класс, если явно передадим ссылку на объект pt, следующим образом:
Point.set_coords(pt) # вызов метода set_coords<__main__.Point object at 0x0000014A2BFFCAC0>
# Именно это на автомате делает Python, когда вызов осуществляется через объекты классов.
# Так зачем понадобилось такое поведение? Дело в том, что метод класса – это тоже его атрибут и когда создаются
# экземпляры класса, то метод становится общим для всех объектов и не копируется в них. Фактически,
# только благодаря параметру self мы «знаем» какой объект вызвал данный метод и можем организовать с ним обратную связь.
class Point:
    color = 'red'
    circle = 2
    def set_coords(self, x, y):
        self.x = x
        self.y = y
# В результате при вызове метода:
pt = Point()
pt.set_coords(1, 2)
print(pt.__dict__) # {'x': 1, 'y': 2}
# в объекте pt будут созданы два свойства x, y со значениями 1 и 2. Вот для чего нужен этот параметр self.
# Если в программе создать еще один объект:
pt2 = Point()
# И через него вызвать тот же метод:
pt2.set_coords(10, 20)
print(pt2.__dict__) # {'x': 10, 'y': 20}
# То увидим, что свойства x, y со значениями 10 и 20 были созданы только в нем (в его пространстве имен)
# и никак не связаны с координатами другого объекта pt или классом Point. То есть, через self мы работаем с конкретным
# объектом, из которого был вызван данный метод.

# Конечно, в классах мы можем прописывать произвольное количество методов.
# Например, определим еще один, который будет возвращать координаты точки в виде кортежа значений:
class Point():
    color = 'red'
    circle = 2
    def set_ccords(self, x, y):
        self.x = x
        self.y = y

    def get_coords(self):
        return (self.x, self.y)

pt = Point()
pt.set_ccords(1, 2)
print(pt.get_coords()) # (1, 2)
# Интересно, что так как имя метода – это атрибут класса, то мы можем обратиться к нему через знакомую нам уже функцию:
res = getattr(pt, 'get_coords')
print(res) # <bound method Point.get_coords of <__main__.Point object at 0x0000014FC9E289A0>>
# Видим, что это ссылка на объект-функцию. А раз так, то ничто нам не мешает ее здесь вызывать:
print(res()) # (1, 2)
# Конечно, так делают очень редко. Обычно используют синтаксис через точку. Я привел это, чтобы еще раз подчеркнуть,
# что имена методов – это те же самые атрибуты, просто они ведут не на данные, а на функции. Во всем остальном они схожи
# с атрибутами-данными класса.